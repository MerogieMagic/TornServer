# Schema Design: Faction Utility (Proposed)

## Overview
This table stores the current state of faction utilities (items used by the faction, distinct from inventory weapons/armor).

## API Source
- **Endpoint:** `https://api.torn.com/v2/faction/utilities`
- **Keys Required:** Public? (Needs verification, user sample used a key).
- **Frequency:** suggested every 10 minutes (600s). Utilities change infrequently.

## Updating Methodology
- **Strategy:** Full Sync (Snapshot).
- **Process:** 
  1. Fetch all utilities from API.
  2. Transaction:
     - Upsert new/changed records based on `tornId`.
     - Delete records that are no longer in the API response (if an item is removed/consumed).
     - Alternatively: Mark `quantity = 0` if not present? (Cleaner to delete if truly gone).

## Proposed Table Structure

### Table Name: `FactionUtility`

| Column Name | SQL Type | Description |
|---|---|---|
| `id` | `INT AUTO_INCREMENT PRIMARY KEY` | Internal database ID. |
| `tornId` | `INT NOT NULL UNIQUE` | The ID provided by Torn API (Item ID). |
| `name` | `VARCHAR(255) NOT NULL` | Item Name (e.g., "Bolt Cutters"). |
| `type` | `VARCHAR(50) NOT NULL` | Item Type (e.g., "Tool", "Material"). |
| `quantity` | `INT NOT NULL DEFAULT 0` | Total quantity owned by faction. |
| `available` | `INT NOT NULL DEFAULT 0` | Quantity currently available (not loaned). |
| `loaned` | `INT NOT NULL DEFAULT 0` | Quantity currently loaned out. |
| `loanedTo` | `JSON NULL` | Stores details of who has borrowed the item. <br>Format: Array of `{userId: number, quantity: number, until: timestamp?}` if available, or just simple user ID if API restricts to single user loan. <br>*Note: Sample showed `loaned_to` as single int or null.* |
| `updatedAt` | `DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` | Last sync time. |

### Metadata / Additional Notes
- `loaned_to` handling: The sample API response shows a single integer. If multiple copies of an item (e.g. 2 "RF Detectors") are loaned to different people, does the API split them into multiple rows with the same `ID`?
  - If YES: `tornId` cannot be UNIQUE. Primary key must be composite or surrogate.
  - If NO (e.g. it shows `loaned: 2` but `loaned_to` becomes complex): We use JSON for `loanedTo`.
  - **Proposed Decision:** Use `JSON` for `loanedTo` to be future-proof. If API returns `int`, store `[int]`.

## Primary Key Choice
- **Proposed:** `id` (Auto-increment).
- **Reason:** Decouples DB identity from Torn ID, allowing flexibility if Torn ID logic changes (e.g. multiple rows per item ID).

## SQL DDL (Generated by Prisma)
```sql
CREATE TABLE `FactionUtility` (
    `id` INTEGER NOT NULL AUTO_INCREMENT,
    `tornId` INTEGER NOT NULL,
    `name` VARCHAR(191) NOT NULL,
    `type` VARCHAR(191) NOT NULL,
    `quantity` INTEGER NOT NULL,
    `available` INTEGER NOT NULL,
    `loaned` INTEGER NOT NULL,
    `loanedTo` JSON NULL,
    `updatedAt` DATETIME(3) NOT NULL,

    UNIQUE INDEX `FactionUtility_tornId_key`(`tornId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```
